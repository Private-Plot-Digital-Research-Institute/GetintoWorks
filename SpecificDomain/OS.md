《现代操作系统：原理与实现》
https://ipads/se.sjtu.edu.cn/cources/os/

[SE315 / 2021 / Welcome (sjtu.edu.cn)](https://ipads.se.sjtu.edu.cn/courses/os/)


### 操作系统结构

#### 复杂度管理方法

MALH方法： 
1. 模块化：系统分为明确定义接口交互的模块，严格保障模块间界限
2. 抽象：模块化的基础上，将接口与内部实现分离。模块的接口应该容忍各种输入，并尽可能严格控制模块对外的输出
3. 分层： 将模块按照一定的原则划分层次，同时减少模块之间的交互
4.  层级：将功能相近的模块组成子系统

#### 宏内核

操作系统所有模块均在内核态
1. 模块化： 可加载内核模块（例如LINUX设备驱动）
2. 抽象： 一切皆文件（UNIX）
3. 分层： LINUX文件系统（VFS, 数据缓存， 块设备层，设备驱动，硬件层）
4. 层级： 内存分配

#### 微内核

将部分模块放到用户态。 三代发展： IPC很慢-> 利用ISA提速IPC->实现安全

#### 外核

操作系统的资源抽象存在两个问题
1. 硬件抽象带来性能损失
2. 针对通用应用的抽象无法适用于特殊应用（例如数据库）


### 内存管理

#### 分页机制

AArch64架构下使用4级页表，48位地址。页表的起始地址存在TTBR0_EL1寄存器中

每个页表项8字节，存储物理地址和权限，一页包含512项

63~48位 不使用（全1或者全0）

47~39位 0级列表索引

38~30 1级页表索引

29~21 2级页表索引

20~12 3级页表索引

11~0 页内偏移量（低12位）

TLB： 转址旁路缓存，在L1和L2 Cache里

页表切换的时候TLB会被刷新

按需页分配(demand paging)： 将新分配的页标记成已分配但未映射至物理内存状态

注意： 页未分配状态也会引起缺页异常，不同操作系统处理方法不同，Linux通过虚拟内存区域判断

最优换页策略： 最长时间不会使用的页

颠簸(thrashing)： 操作系统提供的换页与实际工作负载不匹配

一个解决方案： 工作集模型，将同一工作集的页同时换入换出

内存去重(共享链接库， cow）、内存压缩(linux zswap)、大页（Linux transparent huge page)

小内存分配： SLAB

### 进程管理

#### 进程、线程、纤程

纤程是用户管理的线程。由于完全在用户态执行 ，用yield实现合作式多任务处理，不涉及中断和上下文保存，相比线程每次切换可优化到1900纳秒->500纳秒。一般把程序语言提供的纤程支持称为协程(coroutine) ，会通过yield提示CPU切换

### 操作系统调度

FCFS策略
优点：简单直观
弊端
1. 长短任务混合情况下对短任务不友好
2. 对I/O密集型任务不友好

短任务优先
优点：平均周转时间更短
缺点
1. 必须预知任务时间
2. 表现依赖于任务到达节点
3. 长任务饥饿

ROUND ROBIN & MLFQ

公平共享： 按照用户&任务分组进行系统资源分配

实时操作系统： 确定性，完成时间有明确上界

静态优先级实时调度：

速率单调（Rate Monotonic)

动态优先级实时调度：最早截止时间优先（EDF）对于一组无关的任务，被证明是最优策略

#### 多核调度策略

调度器回答的三个问题：

1. 当前应该调度哪个/些任务？
2. 每个调度的任务应该在哪个核上执行？
3. 每个调度的任务应该执行多久？

- 负载分担问题： 任务在CPU核心


##### 能耗调度策略

EAS（能耗感知调度），把处理器的算力统一为“容量”，并在大小核中选择最合适的“容量”

##### 自定义调度策略

```c
#include<sched.h>

void CPU_SET(int cput, cpu_set_t *set*);
u32 sched_policy;
```

#### 现代调度策略

早期：O（n)调度策略，适用于线程少， 后期线程太多，用O（1），现在：CFS


### 进程间通信

基于共享内存的消息传递vs共享内存

后者好处： 不存在消息的抽象

坏处：
1. 指针和指针相关的数据无法使用
2. 与多进程的隔离性优势相冲突

直接通信： 一方需要标识接收通信的另一方

权限检查， 命名服务

消息队列

微内核IPC： 一个应用程序获取系统服务通常需要通过IPC的方式，因此大部分微内核OS都会优先从**性能角度**来设计和实现IPC

Mach： 传递端口

L4：
1. 短消息寄存器传递： 直接通过不改寄存器+中断进入另一进程，让另一进程读取寄存器数据
问题： 依赖硬件
解决：虚拟消息寄存器
1. 长消息： 用户态->内核->用户态拷贝
惰性调度： 就绪队列的阻塞进程不拿走，假定它们很快就绪
直接进程切换： 移除调度程序，直接从一个进程切换到另一个进程

权限检查， Capability权限机制。内核维护一个IPC内核对象，包含接收者、发送者、缓冲区，发送者需要告知Capability让内核知道

LRPC，迁移线程模型： IPC的优化工作大多数关注1. 优化控制流切换性能 2. 优化数据传输的性能
迁移线程：直接将被调用者的代码作为数据，让调用者执行

Android Binder: 优化的Linux  IPC

### 进程同步

原子操作： 比较和置换，拿取并累加

大部分CPU对64位以下单一地址写操作是原子的，因此不需要额外的硬件指令保护写操作

条件变量cond_wait, cond_signal，注意条件变量要搭配锁使用

生产者-消费者要用两个条件变量

条件变量一次只唤醒一个，在临界区外可能产生丢失唤醒问题

读写锁： 读者锁保护临界区元数据，写着锁保护临界区

偏向写者的读写锁： 加一个新变量，阻止后续的读者

RCU（Read-Copy Update): 读者在写着更新时，要么读到旧的值，要么读到新的值

实现方法： 订阅-发布机制，通过订阅-发布机制来更新指针所指向的地址，进而利用单一地址写操作原子性实现更新任意大小数据
与读-写操作的不同：避免CPU乱序执行带来的问题

银行家算法： 每次分配资源的时候找那些一定能执行完把资源释放的线程

活锁： 两个线程没拿完资源，各自反复陷入等待状态。理论上会被自行解决。也有拿不到资源随机等待一些时间的办法

优先级反转： 同步导致线程执行顺序违反预设优先级
三个线程T1,T2,T3， T3先跑， T1等锁， T2出现时把T3抢占了并且一直在运行，则T1会一直等着T2跑完才有机会让T3也跑完并解锁、
解决： 
1. 不可抢占临界区协议（NCP）， 拿锁的线程不可被抢占
2. 优先级继承（PIP）， 锁的持有者自动继承等待锁线程的优先级
3. 优先级置顶： 锁的持有者直接升到可能拿锁的最高优先级。 即时置顶（IPCP）： 获取锁的时候直接提升 原生置顶（OPCP）：有其他线程竞争的时候提升
NCP与IPCP实现难度较小

futex: 机制繁多的互斥锁

### 文件系统

#### Linux文件系统

索引节点： 管理存储块索引

目录： 特殊类型的文件，保存的是目录项

目录项： 存储文件名、索引节点的数据结构

硬链接和符号链接： 一个文件可以对应多个文件名，多个目录项可以指向同一文件

符号链接： 保存的是一个字符串，表示文件路径，本身只支持读取操作

符号链接不受文件系统边界限制，硬链接只能链接同一个文件系统

存储布局： 超级块，块分配信息，索引节点分配信息，索引节点表，文件数据块

文件描述符：使得VFS无需每次都进行路径解析和检查，每个文件描述符与一个内核数据结构挂钩

页缓存： fsync主动写回，脏页会被定期写回 O_DIRECT不会写入缓存

#### 其他文件系统

FAT:  链式结构存储

NTFS： 核心结构为主文件表（MFT）： 每一行对应一个文件，每一列对应元数据。MFT的内容保留在元数据文件里，元数据文件被保存在MFT的第一条记录里。因此引导区域只有MFT开头几条位置的数据，并通过这些数据找到其他记录

- 元数据文件包含日志文件，保证文件系统崩溃时的一致性
- 元数据还保留了坏簇文件，保存硬件中损坏的簇
- NTFS还存在拓展文件，允许添加拓展功能（例如限制用户所用的磁盘空间大小）

FUSE： 内核帮注册号的FUSE服务转发文件和内容，但是存在频繁的进程切换、请求转发和数据拷贝影响用户态文件系统的性能

中断响应： Linux分为上下两步，上半部必要但轻量级，下半部剩余的，复杂且时延要求低的

软中断是最基本的下半部处理方式，处理函数必须是可重入的，因为硬中断的时候处理器会关中断


>[!可重入]
>函数允许在它被调用结束之前再次调用而不会出错


字符设备，块设备

用户空间IO： UIO： 解决驱动编写的难度问题。经典案例： DPDK，用poll()检查/dev/uioX
虚拟功能IO： VFIO， 引入了虚拟化IOMMU，将设备地址映射为虚拟地址。 UIO缺乏在用户态空间动态创建DMA区域的能力暴露给用户态驱动。（因为这导致进程可以读写任意物理内存），通过IOMMU限制用户空间驱动代码的内存访问能力

内存气球： 解决虚拟机换页问题。 实现一个伪装的驱动，不断根据虚拟机监控器的要求调用操作系统内核接口释放或者分配内存